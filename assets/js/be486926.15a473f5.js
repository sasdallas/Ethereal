"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[3579],{8437:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"your-first-driver/scanning-pci","title":"Scanning the PCI bus","description":"Scanning the PCI bus allows you to find your device.","source":"@site/docs/your-first-driver/scanning-pci.md","sourceDirName":"your-first-driver","slug":"/your-first-driver/scanning-pci","permalink":"/docs/your-first-driver/scanning-pci","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Creating the Driver","permalink":"/docs/your-first-driver/creating-the-driver"},"next":{"title":"Allocating Memory","permalink":"/docs/your-first-driver/allocating-memory"}}');var r=i(4848),s=i(8453);const a={sidebar_position:2},c="Scanning the PCI bus",d={},o=[{value:"Start",id:"start",level:2},{value:"Generic PCI device",id:"generic-pci-device",level:2},{value:"Scanning the PCI bus",id:"scanning-the-pci-bus-1",level:2},{value:"Scan parameters",id:"scan-parameters",level:3},{value:"Reading and writing to the PCI namespace",id:"reading-and-writing-to-the-pci-namespace",level:2},{value:"Getting BARs",id:"getting-bars",level:2},{value:"Interrupts",id:"interrupts",level:2},{value:"Putting it all together",id:"putting-it-all-together",level:2}];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"scanning-the-pci-bus",children:"Scanning the PCI bus"})}),"\n",(0,r.jsx)(n.p,{children:"Scanning the PCI bus allows you to find your device."}),"\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsx)(n.p,{children:"If you don't know what PCI is, then feel free to do some extra googling."}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Quick summary"}),": PCI is a system that can let you locate devices like USB controllers, video cards, etc. easily.",(0,r.jsx)(n.br,{}),"\n","Each PCI device has a vendor and device ID. It also has a class code (so you can identify generic devices, extremely helpful)."]}),(0,r.jsx)(n.p,{children:"Each PCI device has configuration space as well, which allows you to toggle features of the device and read information about it."}),(0,r.jsxs)(n.p,{children:["For more information, see the ",(0,r.jsx)(n.a,{href:"https://osdev.wiki/wiki/PCI",children:"OSDev wiki page"})]})]}),"\n",(0,r.jsx)(n.h2,{id:"start",children:"Start"}),"\n",(0,r.jsx)(n.p,{children:"Let's look for our PCI device. Hexahedron provides many kernel APIs for this."}),"\n",(0,r.jsx)(n.p,{children:"First, include the kernel PCI header:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="drivers/example_driver/main.c"',children:"#include <kernel/drivers/pci.h>\n"})}),"\n",(0,r.jsx)(n.p,{children:"We now have access to the entire kernel PCI API. Hexahedron provides a vast API, so let's go through how to use the most common for a driver."}),"\n",(0,r.jsx)(n.h2,{id:"generic-pci-device",children:"Generic PCI device"}),"\n",(0,r.jsxs)(n.p,{children:["First let's go over the PCI device structure - ",(0,r.jsx)(n.code,{children:"pci_device_t"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="hexahedron/include/kernel/drivers/pci.h"',children:"typedef struct pci_device {\n    uint8_t             bus;                // Bus\n    uint8_t             slot;               // Slot\n    uint8_t             function;           // Function\n    uint8_t             class_code;         // Class code\n    uint8_t             subclass_code;      // Subclass code\n    uint16_t            vid;                // Vendor ID\n    uint16_t            pid;                // Product ID\n    void                *driver;            // Driver-specific field                       \n\n    uint32_t            msi_offset;         // MSI offset in configuration space (or 0xFF if not found)\n    uint32_t            msix_offset;        // MSI-X offset in configuration space (or 0xFF if not found)\n\n    int                 valid;              // !!!: Valid device hack\n    uint32_t msix_index;                    // MSIX index\n} pci_device_t;\n"})}),"\n",(0,r.jsx)(n.p,{children:"The only fields you want are at the top. These PCI device structures are all arranged in an array so updating one will update it for everyhting else."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"bus"}),", ",(0,r.jsx)(n.code,{children:"slot"}),", and ",(0,r.jsx)(n.code,{children:"function"})," are all specific to the location of the PCI device on the system."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"class_code"})," and ",(0,r.jsx)(n.code,{children:"subclass_code"})," give details on the function of the device"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"vid"})," and ",(0,r.jsx)(n.code,{children:"pid"})," provide the aforementioned vendor and device IDs"]}),"\n",(0,r.jsxs)(n.admonition,{type:"caution",children:[(0,r.jsxs)(n.p,{children:["Hexahedron's PCI API tends to flip flop between using ",(0,r.jsx)(n.code,{children:"pci_device_t"})," and accepting ",(0,r.jsx)(n.code,{children:"bus"}),", ",(0,r.jsx)(n.code,{children:"slot"}),", ",(0,r.jsx)(n.code,{children:"func"})," manually."]}),(0,r.jsxs)(n.p,{children:["Gradually, the goal is to switch over to ",(0,r.jsx)(n.code,{children:"pci_device_t"})," fully."]})]}),"\n",(0,r.jsx)(n.h2,{id:"scanning-the-pci-bus-1",children:"Scanning the PCI bus"}),"\n",(0,r.jsxs)(n.p,{children:["The API to scan the PCI bus is ",(0,r.jsx)(n.code,{children:"pci_scanDevice"}),", declared as so:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"int pci_scanDevice(pci_scan_callback_t callback, pci_scan_parameters_t *parameters, void *data); \n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"callback"})," contains the scan callback. For each device that matches ",(0,r.jsx)(n.code,{children:"parameters"}),", callback is called."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"parameters"})," will be covered later (note that it is optional, you can leave it as NULL to enumerate ",(0,r.jsx)(n.em,{children:"every PCI device"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Callback have the following signature:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"/**\n * @brief PCI scan callback function\n * @param device The device currently being checked\n * @param data Driver-specific\n * @returns 1 on an error, 0 on success\n */\ntypedef int (*pci_scan_callback_t)(pci_device_t *device, void *data);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"data"})," is passed directly as it was in ",(0,r.jsx)(n.code,{children:"pci_scanDevice"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Returning 1 means that an error occurred, and to ",(0,r.jsxs)(n.strong,{children:["stop the scan and return an error from ",(0,r.jsx)(n.code,{children:"pci_scanDevice"})]})]}),"\n",(0,r.jsx)(n.h3,{id:"scan-parameters",children:"Scan parameters"}),"\n",(0,r.jsx)(n.p,{children:"Scan parameters are the most complicated part of this interface. Let's look at an example from the UHCI driver."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="drivers/usb/uhci/uhci.c"',children:"pci_scan_parameters_t params = {\n    .class_code = 0x0C,     // Serial bus controller \n    .subclass_code = 0x03,  // Universal Serial Bus\n    .id_list = NULL,        // Optional ID list\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This means that the scan callback will only be called if a device with that class and subclass code is found."}),"\n",(0,r.jsx)(n.p,{children:"But sometimes, you need to do some VID/PID identification. That's fine, let's go over how to do that. This sample is taken from the RTL8169 driver."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="drivers/net/rtl8169/rtl8169.c"',children:"pci_id_mapping_t id_list[] = {\n    { .vid = 0x10ec, .pid = { 0x8161, 0x8168, 0x8169, 0x2600, PCI_NONE } },\n    { .vid = 0x1259, .pid = { 0xc107, PCI_NONE } },\n    { .vid = 0x1737, .pid = { 0x1032, PCI_NONE } },\n    { .vid = 0x16ec, .pid = { 0x0116, PCI_NONE } },\n    PCI_ID_MAPPING_END\n};\n\npci_scan_parameters_t params = {\n    .class_code = 0,\n    .subclass_code = 0,\n    .id_list = id_list\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"Ignore the specific hexadecimals. They are not important."}),"\n",(0,r.jsxs)(n.p,{children:["The important part is that the id_list is an array of ",(0,r.jsx)(n.code,{children:"pci_id_mapping_t"})," structures, ",(0,r.jsxs)(n.strong,{children:["finished with ",(0,r.jsx)(n.code,{children:"PCI_ID_MAPPING_END"})]})," ",(0,r.jsx)(n.br,{}),"\n","The PID list must ",(0,r.jsxs)(n.strong,{children:["also be finished with ",(0,r.jsx)(n.code,{children:"PCI_NONE"})]})," , else the kernel will most likely crash"]}),"\n",(0,r.jsxs)(n.p,{children:["There also exists a ",(0,r.jsx)(n.code,{children:"PCI_PID_ACCEPT_ALL"}),", which can be set as ",(0,r.jsx)(n.code,{children:"{ .vid = VID, .pid = PCI_PID_ACCEPT_ALL },"}),". It means that all PIDs will be accepted."]}),"\n",(0,r.jsx)(n.h2,{id:"reading-and-writing-to-the-pci-namespace",children:"Reading and writing to the PCI namespace"}),"\n",(0,r.jsx)(n.p,{children:"You can read/write to the PCI namespace with the following functions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Read a specific offset from the PCI configuration space\n * \n * Uses configuration space access mechanism #1.\n * List of offsets is header-specific except for general header layout, see pci.h\n * \n * @param bus The bus of the PCI device to read from\n * @param slot The slot of the PCI device to read from\n * @param func The function of the PCI device to read (if the device supports multiple functions)\n * @param offset The offset to read from\n * @param size The size of the value you want to read from. Do note that you'll have to typecast to this (max uint32_t).\n * \n * @returns Either PCI_NONE if an invalid size was specified, or a value according to @c size\n */\nuint32_t pci_readConfigOffset(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset, int size);\n\n\n/**\n * @brief Write to a specific offset in the PCI configuration space\n * \n * @param bus The bus of the PCI device to write to\n * @param slot The slot of the PCI device to write to\n * @param func The function of the PCI device to write (if the device supports multiple functions)\n * @param offset The offset to write to\n * @param value The value to write\n * @param size How big of a value to write\n * \n * @returns 0 on success\n */\nint pci_writeConfigOffset(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset, uint32_t value, int size)\n"})}),"\n",(0,r.jsx)(n.p,{children:"These functions are self explanatory."}),"\n",(0,r.jsx)(n.h2,{id:"getting-bars",children:"Getting BARs"}),"\n",(0,r.jsxs)(n.p,{children:["Getting BARs of PCI devices is easily done with ",(0,r.jsx)(n.code,{children:"pci_readBAR"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"/**\n * @brief Auto-determine a BAR type and read it using the configuration space\n * \n * Returns a pointer to an ALLOCATED @c pci_bar_t structure. You MUST free this structure\n * when you're finished with it!\n * \n * @param bus Bus of the PCI device\n * @param slot Slot of the PCI device\n * @param func Function of the PCI device\n * @param bar The number of the BAR to read\n * \n * @returns A @c pci_bar_t structure or NULL  \n */\npci_bar_t *pci_readBAR(uint8_t bus, uint8_t slot, uint8_t func, uint8_t bar);\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"danger",children:(0,r.jsxs)(n.p,{children:["The structure returned by ",(0,r.jsx)(n.code,{children:"pci_readBAR"})," is allocated and you must free it."]})}),"\n",(0,r.jsx)(n.p,{children:"The PCI bar structure returned looks like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="hexahedron/include/kernel/drivers/pci.h"',children:"/* BAR types */\n#define PCI_BAR_MEMORY32            ...     // 32-bit memory space BAR (physical RAM) \n#define PCI_BAR_IO_SPACE            ...     // I/O space BAR, can reside at any memory address\n#define PCI_BAR_MEMORY16            ...     // 16-bit memory space BAR (reserved nowadays) \n#define PCI_BAR_MEMORY64            ...     // 64-bit memory space BAR\n\n\ntypedef struct pci_bar {\n    int type;           // Type of the BAR\n    uint64_t size;      // Size of the BAR\n    int prefetchable;   // Whether the BAR is prefetchable (it does not read side effects)\n    uint64_t address;   // Address of the BAR. Note that it doesn't take up all of this space.s\n} pci_bar_t;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"interrupts",children:"Interrupts"}),"\n",(0,r.jsx)(n.p,{children:"Interrupts are complicated in PCI, and Ethereal's interfaces can be convoluted."}),"\n",(0,r.jsx)(n.p,{children:"There are three types of PCI interrupts:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["MSIX interrupt (",(0,r.jsx)(n.strong,{children:"recommended"}),", Ethereal allows you to get multiple)"]}),"\n",(0,r.jsx)(n.li,{children:"MSI interrupt (good)"}),"\n",(0,r.jsxs)(n.li,{children:["Pin interrupt (",(0,r.jsx)(n.strong,{children:"bad"}),", may be incompatible)"]}),"\n"]}),"\n",(0,r.jsxs)(n.admonition,{type:"danger",children:[(0,r.jsx)(n.p,{children:'"May be incompatible" is an understatement. Because of modern hardware and bad design, ACPI AML parsing is required to parse the GSI of the PCI pin interrupt'}),(0,r.jsxs)(n.p,{children:["This interface is not yet implemented in Ethereal (the code is prototyped), so for all intensive purposes ",(0,r.jsx)(n.strong,{children:"assume pin interrupts will not work, period"})]})]}),"\n",(0,r.jsx)(n.admonition,{type:"danger",children:(0,r.jsx)(n.p,{children:"Interrupts are the worst part of the Ethereal PCI API"})}),"\n",(0,r.jsx)(n.p,{children:"Ethereal has two interfaces for all three interrupt types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"uint8_t pci_enableMSI(uint8_t bus, uint8_t slot, uint8_t func);\nuint8_t pci_getInterrupt(uint8_t bus, uint8_t slot, uint8_t func);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"pci_enableMSI"})," will also attempt to enable MSI-X if it is available (and it will be preferred)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"pci_getInterrupt"})," is for legacy pin interrupts and ",(0,r.jsx)(n.strong,{children:"again, should not be used"})]}),"\n",(0,r.jsx)(n.h2,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,r.jsx)(n.p,{children:"Putting all of this together, let's expand our example driver."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",metastring:'title="drivers/example/example.c',children:'/**\n * @brief PCI example\n */\n\n#include <kernel/loader/driver.h>\n#include <kernel/debug.h>\n#include <kernel/drivers/pci.h>\n\n\nint driver_scanCallback(pci_device_t *device, void *context) {\n    dprintf(INFO, "Found matching device at bus %d slot %d func %d\\n", device->bus, device->slot, device->function);\n    \n    // Get BAR0\n    pci_bar_t *b = pci_getBAR(device->bus, device->slot, device->function, 0);\n    assert(b);\n\n    // Now what???\n    // We\'ve got to map the BAR in!\n\n    return 0;\n}\n\nint driver_init(int argc, char *argv[]) {\n    dprintf(DEBUG, "Scanning for example PCI device with VID 1234 and PID 1111...\\n");\n\n    pci_id_mapping_t id_list[] = {\n        { .vid = 0x1234, .pid = { 0x1111, PCI_NONE }},\n        PCI_ID_MAPPING_END\n    };\n\n    pci_scan_parameters_t params = {\n        .class_code = 0,            // No class code\n        .subclass_code = 0,         // No class code\n        .id_list = id_list\n    };\n\n    return pci_scan(driver_scanCallback, &params, NULL);\n}\n\nint driver_deinit() { return DRIVER_STATUS_SUCCESS; }\n\nstruct driver_metadata driver_metadata = {\n    .name = "Example Driver",\n    .author = "Your Name Here",\n    .init = driver_init,\n    .deinit = driver_deinit\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"This updated driver scans for a PCI device matching 1234:1111."}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["This is the PCI VID",":PID"," of the Bochs Graphics Adapter, so QEMU will in fact pick it up."]}),(0,r.jsxs)(n.p,{children:["We will not be creating a BGA driver, as an implementation is already available in ",(0,r.jsx)(n.code,{children:"drivers/graphics/bga"})]}),(0,r.jsx)(n.p,{children:"Instead this driver creation tutorial will cover a fake magic PCI device."})]}),"\n",(0,r.jsxs)(n.p,{children:["Continue on ",(0,r.jsx)(n.a,{href:"/docs/your-first-driver/allocating-memory",children:"3 - allocating memory"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);
"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[7264],{118:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"your-first-driver/creating-the-driver","title":"Creating the Driver","description":"Creating a kernel-mode driver in Ethereal is extremely easy.","source":"@site/docs/your-first-driver/creating-the-driver.md","sourceDirName":"your-first-driver","slug":"/your-first-driver/creating-the-driver","permalink":"/docs/your-first-driver/creating-the-driver","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Creating your first Driver","permalink":"/docs/category/creating-your-first-driver"},"next":{"title":"Scanning the PCI bus","permalink":"/docs/your-first-driver/scanning-pci"}}');var d=i(4848),t=i(8453);const s={sidebar_position:1},l="Creating the Driver",a={},o=[{value:"Driver Structure",id:"driver-structure",level:2},{value:"Creating your first driver",id:"creating-your-first-driver",level:2},{value:"The actual C code",id:"the-actual-c-code",level:2},{value:"Breakdown of the C code",id:"breakdown-of-the-c-code",level:2},{value:"driver_init",id:"driver_init",level:3},{value:"dprintf",id:"dprintf",level:3},{value:"driver_deinit",id:"driver_deinit",level:3},{value:"driver_metadata",id:"driver_metadata",level:3},{value:"Testing your driver",id:"testing-your-driver",level:2}];function c(e){const r={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(r.header,{children:(0,d.jsx)(r.h1,{id:"creating-the-driver",children:"Creating the Driver"})}),"\n",(0,d.jsx)(r.p,{children:"Creating a kernel-mode driver in Ethereal is extremely easy."}),"\n",(0,d.jsx)(r.admonition,{type:"info",children:(0,d.jsx)(r.p,{children:"Only C is supported for driver development at the moment."})}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsxs)(r.strong,{children:["All drivers for Ethereal are placed under the ",(0,d.jsx)(r.code,{children:"drivers"})," directory. Subdirectories are supported if they have a make.config file in them."]})}),"\n",(0,d.jsx)(r.h2,{id:"driver-structure",children:"Driver Structure"}),"\n",(0,d.jsx)(r.p,{children:"A generic driver has the following folder structure:"}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-text",children:"driver/\n\u251c\u2500 driver.conf\n\u251c\u2500 main.c\n\u251c\u2500 Makefile\n"})}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"driver.conf"}),": Contains configuration information about the driver"]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"main.c"}),": Contains the driver's code (you can have multiple C files)"]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"Makefile"}),": ",(0,d.jsx)(r.strong,{children:"You do not make this"})," - copy it from a nearby driver (the same Makefile will work for any driver)"]}),"\n"]}),"\n",(0,d.jsx)(r.h2,{id:"creating-your-first-driver",children:"Creating your first driver"}),"\n",(0,d.jsxs)(r.p,{children:["Let's call our driver the example driver, and have its folder be called ",(0,d.jsx)(r.code,{children:"example"}),"."]}),"\n",(0,d.jsxs)(r.p,{children:["We will place its files under ",(0,d.jsx)(r.code,{children:"drivers/example/"})," - you can view the reference implementation of this driver in the kernel ",(0,d.jsx)(r.a,{href:"https://github.com/sasdallas/Ethereal/tree/main/drivers/example/",children:"at the main build tree"})]}),"\n",(0,d.jsx)(r.p,{children:"First, the config file."}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-text",metastring:'title="drivers/example/driver.conf"',children:'FILENAME = "example_driver.sys"\nENVIRONMENT = ANY\nPRIORITY = IGNORE\nARCH = ANY\n'})}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"FILENAME"}),": This dictates the filename of your driver to place in ",(0,d.jsx)(r.code,{children:"/boot/drivers/"})]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"ENVIRONMENT"}),": Mainly legacy code at this point. ",(0,d.jsx)(r.code,{children:"ENVIRONMENT"})," was a planned expansion but was never finished."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"PRIORITY"}),": Options include ",(0,d.jsx)(r.code,{children:"IGNORE"})," (if the driver fails to load it will be ignored), ",(0,d.jsx)(r.code,{children:"WARN"})," (warn the user if the driver fails to load), and ",(0,d.jsx)(r.code,{children:"CRITICAL"})," (crash on load failure)"]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"ARCH"}),": Supported architectures for your driver. You can separate architectures by ",(0,d.jsx)(r.code,{children:"OR"}),", so ",(0,d.jsx)(r.code,{children:"X86_64 OR I386"})," is perfectly valid."]}),"\n"]}),"\n",(0,d.jsxs)(r.p,{children:["Awesome, now ",(0,d.jsxs)(r.strong,{children:["copy the Makefile from any other driver into ",(0,d.jsx)(r.code,{children:"drivers/example/Makefile"})]})," and the driver structure is finished."]}),"\n",(0,d.jsx)(r.h2,{id:"the-actual-c-code",children:"The actual C code"}),"\n",(0,d.jsx)(r.p,{children:"Let's make a hello world driver!"}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-c",metastring:'title="drivers/example/main.c"',children:'/**\n * @brief Example driver\n */\n\n#include <kernel/loader/driver.h>\n#include <kernel/debug.h>\n\n/**\n * @brief The main driver init method\n * @param argc The argument count\n * @param argv The argument list\n * \n * @note    @c argc and @c argv only apply when loaded from userspace with @c driverctl\n *          Support for these two are very limited!\n */\nint driver_init(int argc, char *argv[]) {\n    dprintf(DEBUG, "Hello, driver world!\\n");\n    return DRIVER_STATUS_SUCCESS;\n}\n\n/**\n * @brief The main driver deinit method\n * Called on driver shutdown\n */\nint driver_deinit() {\n    return DRIVER_STATUS_SUCCESS;\n}\n\nstruct driver_metadata driver_metadata = {\n    .name = "Example Driver",\n    .author = "Your Name Here",\n    .init = driver_init,\n    .deinit = driver_deinit,\n};\n\n'})}),"\n",(0,d.jsx)(r.h2,{id:"breakdown-of-the-c-code",children:"Breakdown of the C code"}),"\n",(0,d.jsx)(r.p,{children:"Let's break some of this down."}),"\n",(0,d.jsx)(r.h3,{id:"driver_init",children:"driver_init"}),"\n",(0,d.jsxs)(r.p,{children:["This is the main method of the driver. It doesn't necessarily have to be called ",(0,d.jsx)(r.code,{children:"driver_init"}),", just has to match what's in the metadata."]}),"\n",(0,d.jsx)(r.p,{children:"It is given a list of arguments. This list is pretty unimportant, as it only applies with drivers loaded by userspace (so for debugging only) - it's just a standard argc/argv like in any C program."}),"\n",(0,d.jsxs)(r.p,{children:["The ",(0,d.jsx)(r.strong,{children:"return value"}),", ",(0,d.jsx)(r.code,{children:"DRIVER_STATUS_SUCCESS"}),", currently has four possible values:"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"DRIVER_STATUS_SUCCESS"}),": No error. Your driver is left loaded in memory."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"DRIVER_STATUS_UNSUPPORTED"}),": Unsupported components detected. This is an error."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"DRIVER_STATUS_NO_DEVICE"}),": Your driver loaded, but a device was not found. This is a noncritical error and your driver is unloaded from memory."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"DRIVER_STATUS_ERROR"}),": Generic driver error."]}),"\n"]}),"\n",(0,d.jsx)(r.h3,{id:"dprintf",children:"dprintf"}),"\n",(0,d.jsxs)(r.p,{children:["This is the kernel's debug print macro. ",(0,d.jsx)(r.code,{children:"DEBUG"})," is the log level, and after the status it acts as a normal printf."]}),"\n",(0,d.jsxs)(r.admonition,{type:"tip",children:[(0,d.jsxs)(r.p,{children:["The recommended function for logging in drivers is ",(0,d.jsx)(r.code,{children:"dprintf_module"}),", which has the following signature:"]}),(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-c",children:'dprintf_module(DEBUG, "DRIVER:EXAMPLE", "Hello, world!\\n");\n'})}),(0,d.jsxs)(r.p,{children:["A common practice in Ethereal is to define a ",(0,d.jsx)(r.code,{children:"LOG"})," macro like so:"]}),(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-c",children:'#define LOG(status, ...) dprintf_module(status, "DRIVER:EXAMPLE", __VA_ARGS__)\nLOG(DEBUG, "Hello!\\n");\n'})})]}),"\n",(0,d.jsx)(r.admonition,{type:"info",children:(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.code,{children:"DEBUG"}),", ",(0,d.jsx)(r.code,{children:"ERR"}),", ",(0,d.jsx)(r.code,{children:"INFO"}),", ",(0,d.jsx)(r.code,{children:"WARN"}),", and ",(0,d.jsx)(r.code,{children:"NOHEADER"})," are all available log levels."]})}),"\n",(0,d.jsx)(r.h3,{id:"driver_deinit",children:"driver_deinit"}),"\n",(0,d.jsx)(r.p,{children:"Called whenever the system begins to power down and is unloading you. Cleanup and free your resources!"}),"\n",(0,d.jsx)(r.admonition,{type:"note",children:(0,d.jsx)(r.p,{children:"The return value of this isn't checked"})}),"\n",(0,d.jsx)(r.h3,{id:"driver_metadata",children:"driver_metadata"}),"\n",(0,d.jsx)(r.p,{children:(0,d.jsxs)(r.strong,{children:["The name of this ",(0,d.jsx)(r.em,{children:"MUST"})," be ",(0,d.jsx)(r.code,{children:"driver_metadata"})]})}),"\n",(0,d.jsx)(r.p,{children:"The kernel uses this to get more metadata on your driver. It has the driver's name, its author, init method, and deinit method."}),"\n",(0,d.jsx)(r.admonition,{type:"note",children:(0,d.jsx)(r.p,{children:"In the future, this structure will be upgraded. Details are not known right now, but backwards compatibility with other drivers will be maintained."})}),"\n",(0,d.jsx)(r.h2,{id:"testing-your-driver",children:"Testing your driver"}),"\n",(0,d.jsxs)(r.p,{children:["Assuming you placed your driver in ",(0,d.jsx)(r.code,{children:"drivers/"})," in the Ethereal repo, you will be able to just rebuild Ethereal and it will automatically build your driver."]}),"\n",(0,d.jsx)(r.p,{children:"On running Ethereal you should see this in the serial output:"}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-text",children:'[1.000000] [CPU0] [INFO] [DRIVER] Loading driver "/device/initrd/boot/drivers/example_driver.sys" with priority IGNORE...\n[1.000001] [CPU0] [DBG ] Hello, driver world!\n'})}),"\n",(0,d.jsx)(r.p,{children:"Congrats! You have designed your first driver."}),"\n",(0,d.jsxs)(r.p,{children:["Continue onto ",(0,d.jsx)(r.a,{href:"/docs/your-first-driver/scanning-pci/",children:"scanning the PCI bus"}),"."]})]})}function h(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,d.jsx)(r,{...e,children:(0,d.jsx)(c,{...e})}):c(e)}},8453:(e,r,i)=>{i.d(r,{R:()=>s,x:()=>l});var n=i(6540);const d={},t=n.createContext(d);function s(e){const r=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:s(e.components),n.createElement(t.Provider,{value:r},e.children)}}}]);
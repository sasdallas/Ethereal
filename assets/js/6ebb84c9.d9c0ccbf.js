"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[5932],{795:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"your-first-driver/allocating-memory","title":"Allocating Memory","description":"Ethereal provides many memory allocation routines, some good and some bad.","source":"@site/docs/your-first-driver/allocating-memory.md","sourceDirName":"your-first-driver","slug":"/your-first-driver/allocating-memory","permalink":"/docs/your-first-driver/allocating-memory","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Scanning the PCI bus","permalink":"/docs/your-first-driver/scanning-pci"},"next":{"title":"HAL","permalink":"/docs/your-first-driver/hal"}}');var s=i(4848),a=i(8453);const t={sidebar_position:3},o="Allocating Memory",l={},d=[{value:"Heap Memory",id:"heap-memory",level:2},{value:"DMA/MMIO",id:"dmammio",level:2},{value:"Managing your own memory",id:"managing-your-own-memory",level:2},{value:"Pages",id:"pages",level:3},{value:"Getting pages",id:"getting-pages",level:3},{value:"Allocating frames for pages",id:"allocating-frames-for-pages",level:3},{value:"Physical memory manipulation",id:"physical-memory-manipulation",level:3},{value:"Putting it all together",id:"putting-it-all-together",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"allocating-memory",children:"Allocating Memory"})}),"\n",(0,s.jsx)(n.p,{children:"Ethereal provides many memory allocation routines, some good and some bad."}),"\n",(0,s.jsx)(n.h2,{id:"heap-memory",children:"Heap Memory"}),"\n",(0,s.jsx)(n.p,{children:"Heap memory is the most common type of memory that a driver would need to acquire."}),"\n",(0,s.jsx)(n.p,{children:"To acquire heap memory, Ethereal provides common kernel replacement functions for standard C ones."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"void *kmalloc(size_t sz);\nvoid kfree(void *p);\nvoid *krealloc(void *p, size_t sz);\nvoid *kcalloc(size_t n, size_t size);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["These functions work exactly the same as ",(0,s.jsx)(n.code,{children:"malloc"}),", ",(0,s.jsx)(n.code,{children:"free"}),", etc. and provide general-purpose heap functions."]}),"\n",(0,s.jsx)(n.h2,{id:"dmammio",children:"DMA/MMIO"}),"\n",(0,s.jsx)(n.p,{children:"DMA and MMIO are special subsets of memory that require specific page permissions."}),"\n",(0,s.jsx)(n.p,{children:"Ethereal provides APIs to automatically allocate and free DMA/MMIO memory."}),"\n",(0,s.jsxs)(n.p,{children:["DMA can be allocated and freed with the ",(0,s.jsx)(n.code,{children:"mem_allocateDMA"}),"/",(0,s.jsx)(n.code,{children:"mem_freeDMA"})," functions, which are defined as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'file="hexahedron/include/kernel/mem/mem.h"',children:"uintptr_t mem_allocateDMA(size_t size);\nvoid mem_freeDMA(uintptr_t base, uintptr_t size);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["DMA is mapped as ",(0,s.jsx)(n.strong,{children:"non-cacheable kernel mode memory"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["MMIO can be allocated and freed with the ",(0,s.jsx)(n.code,{children:"mem_mapMMIO"}),"/",(0,s.jsx)(n.code,{children:"mem_unmapMMIO"})," functions, which are defined as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'file="hexahedron/include/kernel/mem/mem.h"',children:"uintptr_t mem_mapMMIO(uintptr_t phys, size_t size);\nvoid mem_unmapMMIO(uintptr_t virt, uintptr_t size);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["MMIO is mapped as ",(0,s.jsx)(n.strong,{children:"non-cacheable kernel mode memory"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"managing-your-own-memory",children:"Managing your own memory"}),"\n",(0,s.jsxs)(n.admonition,{type:"danger",children:[(0,s.jsx)(n.p,{children:"Ethereal's memory API may make you violently rage.\nSend all threats for me to GitHub issues."}),(0,s.jsxs)(n.p,{children:["In all seriousness, the memory API is okay except for a few functions. Below are for ",(0,s.jsx)(n.strong,{children:"very specific cases"})," and in most times aren't needed."]})]}),"\n",(0,s.jsx)(n.p,{children:"This is where the meat comes into play. Let's look at VMM functions."}),"\n",(0,s.jsx)(n.h3,{id:"pages",children:"Pages"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"page_t"})," structure varies from architecture to architecture, so all architectures are required to define the following macros:"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["For example implementations, see ",(0,s.jsx)(n.code,{children:"hexahedron/include/arch/x86_64/mem.h"})]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"#define MEM_ALIGN_PAGE(addr) ... // Graciously align an address to the nearest page\n#define MEM_ALIGN_PAGE_DESTRUCTIVE(addr) ... // Align an address to the nearest page, discarding any bits\n\n/* The following are GETTERS. They are one way */\n#define PAGE_IS_PRESENT(pg) ...\n#define PAGE_IS_WRITABLE(pg) ...\n#define PAGE_IS_USERMODE(pg) ...\n#define PAGE_IS_COW(pg) ...\n#define PAGE_IS_DIRTY(pg) ...\n\n/* The following are SETTERS. You can set them, but getting them is not recommended. */\n#define PAGE_PRESENT(pg) ...\n#define PAGE_COW(pg) ...\n#define PAGE_FRAME_RAW(pg) ...\n\n#define MEM_SET_FRAME(pg, frame) ... // Set the frame of a page\n#define MEM_GET_FRAME(pg) ... // Get the frame of a page\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getting-pages",children:"Getting pages"}),"\n",(0,s.jsxs)(n.p,{children:["To get a page, use the ",(0,s.jsx)(n.code,{children:"mem_getPage"})," function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"page_t *mem_getPage(page_t *dir, uintptr_t virt, int flags);\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dir"}),": Specifies the page directory to get the page in. Leave as ",(0,s.jsx)(n.code,{children:"NULL"})," to use the current."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"virt"}),": The target virtual address"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"flags"}),": Mainly either ",(0,s.jsx)(n.code,{children:"MEM_DEFAULT"})," or ",(0,s.jsx)(n.code,{children:"MEM_CREATE"}),". If ",(0,s.jsx)(n.code,{children:"MEM_CREATE"})," is specified, the page is created and returned."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Returns a pointer to a page object or NULL depending on flags."}),"\n",(0,s.jsx)(n.h3,{id:"allocating-frames-for-pages",children:"Allocating frames for pages"}),"\n",(0,s.jsx)(n.p,{children:"Hexahedron provides a dedicated API call for this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"void mem_allocatePage(page_t *page, uintptr_t flags);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Pass your page and set your flags to customize the page's protection bits + frame."}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["Normally this will also allocate a new frame for your page and set it (use ",(0,s.jsx)(n.code,{children:"MEM_PAGE_NOALLOC"})," to stop this)."]})}),"\n",(0,s.jsx)(n.p,{children:"Available flags:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEM_DEFAULT"}),": Default protection is URWX."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEM_PAGE_KERNEL"}),": Kernel mode only page"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEM_PAGE_READONLY"}),": Read only page"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEM_PAGE_WRITETHROUGH"}),": Enable writethrough on the page"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEM_PAGE_NOT_CACHEABLE"}),": UC"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEM_PAGE_NOT_PRESENT"}),": The page is no longer present in memory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEM_PAGE_NOALLOC"}),": Use this ",(0,s.jsx)(n.strong,{children:"when you just want to change a page's protection flags"}),". This means that ",(0,s.jsx)(n.strong,{children:"a new frame won't be allocated when you call this"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEM_PAGE_FREE"}),": Free the page. Basically just passes your page to ",(0,s.jsx)(n.code,{children:"mem_freePage"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEM_PAGE_NO_EXECUTE"}),": Only on supported architectures. Enables NX."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MEM_PAGE_WRITE_COMBINE"}),": Only on supported architectures. Enables WC."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You can free any page with the ",(0,s.jsx)(n.code,{children:"mem_freePage"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"void mem_freePage(page_t *page);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"physical-memory-manipulation",children:"Physical memory manipulation"}),"\n",(0,s.jsxs)(n.p,{children:["You can map physical to virtual memory with ",(0,s.jsx)(n.code,{children:"mem_mapAddress"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"void mem_mapAddress(page_t *dir, uintptr_t phys, uintptr_t virt, int flags);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Alternatively, for short physical memory accesses try HHDM:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"uintptr_t mem_remapPhys(uintptr_t frame_address, uintptr_t size);\nvoid mem_unmapPhys(uintptr_t frame_address, uintptr_t size);\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsxs)(n.p,{children:["Upon finishing with your remapped physical memory, call ",(0,s.jsx)(n.code,{children:"mem_unmapPhys"}),"."]}),(0,s.jsx)(n.p,{children:"This is because of the i386 memory pool system."})]}),"\n",(0,s.jsx)(n.h2,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,s.jsx)(n.p,{children:"Let's map our BAR into memory."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'/**\n * @brief PCI example\n */\n\n#include <kernel/loader/driver.h>\n#include <kernel/debug.h>\n#include <kernel/drivers/pci.h>\n#include <kernel/mem/mem.h>\n#include <string.h>\n\n\nint driver_scanCallback(pci_device_t *device, void *context) {\n    dprintf(INFO, "Found matching device at bus %d slot %d func %d\\n", device->bus, device->slot, device->function);\n    \n    // Get BAR0\n    pci_bar_t *b = pci_getBAR(device->bus, device->slot, device->function, 0);\n    assert(b);\n\n    // Map it as MMIO\n    uintptr_t m = mem_mapMMIO(b->address, b->size);\n    dprintf(DEBUG, "Mapped memory to 0x%016llX\\n", m);\n    memset(m, 0, b->size);\n\n    mem_unmapMMIO(m, b->size);\n\n    return 0;\n}\n\nint driver_init(int argc, char *argv[]) {\n    dprintf(DEBUG, "Scanning for example PCI device with VID 1234 and PID 1111...\\n");\n\n    pci_id_mapping_t id_list[] = {\n        { .vid = 0x1234, .pid = { 0x1111, PCI_NONE }},\n        PCI_ID_MAPPING_END\n    };\n\n    pci_scan_parameters_t params = {\n        .class_code = 0,            // No class code\n        .subclass_code = 0,         // No class code\n        .id_list = id_list\n    };\n\n    return pci_scan(driver_scanCallback, &params, NULL);\n}\n\nint driver_deinit() { return DRIVER_STATUS_SUCCESS; }\n\nstruct driver_metadata driver_metadata = {\n    .name = "Example Driver",\n    .author = "Your Name Here",\n    .init = driver_init,\n    .deinit = driver_deinit\n};\n'})})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var r=i(6540);const s={},a=r.createContext(s);function t(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);
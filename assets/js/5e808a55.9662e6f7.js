"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[318],{6857:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"your-first-driver/hal","title":"HAL","description":"The Hardware Abstraction Layer is an important part of Ethereal\'s hardware API.","source":"@site/docs/your-first-driver/hal.md","sourceDirName":"your-first-driver","slug":"/your-first-driver/hal","permalink":"/docs/your-first-driver/hal","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Allocating Memory","permalink":"/docs/your-first-driver/allocating-memory"},"next":{"title":"Threads and Processes","permalink":"/docs/your-first-driver/threading"}}');var i=r(4848),a=r(8453);const d={sidebar_position:4},s="HAL",l={},o=[{value:"Interrupts",id:"interrupts",level:2},{value:"Handlers",id:"handlers",level:3},{value:"Putting it all together",id:"putting-it-all-together",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"hal",children:"HAL"})}),"\n",(0,i.jsx)(n.p,{children:"The Hardware Abstraction Layer is an important part of Ethereal's hardware API."}),"\n",(0,i.jsx)(n.h2,{id:"interrupts",children:"Interrupts"}),"\n",(0,i.jsx)(n.h3,{id:"handlers",children:"Handlers"}),"\n",(0,i.jsx)(n.p,{children:"Registering interrupts can be done with the HAL through the following function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"int hal_registerInterruptHandler(uintptr_t int_number, hal_interrupt_handler_t handler, void *context);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"int_number"}),": The target interrupt number to use"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"handler"}),": The handler to use"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"context"}),": The context to pass to the handler"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The interrupt handler is declared as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"typedef int (*hal_interrupt_handler_t)(void *context);\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"danger",children:(0,i.jsxs)(n.p,{children:["Returning nonzero from an interrupt handler will cause ",(0,i.jsx)(n.code,{children:"IRQ_HANDLER_FAILED"})," to be thrown."]})}),"\n",(0,i.jsx)(n.p,{children:"You can unregister interrupt handlers using the following function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"void hal_unregisterInterruptHandler(uintptr_t int_no);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,i.jsx)(n.p,{children:"Let's combine our knowledge of the PCI and HAL API to register an interrupt handler for our fake device."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'\n/**\n * @brief PCI example\n */\n\n#include <kernel/loader/driver.h>\n#include <kernel/debug.h>\n#include <kernel/drivers/pci.h>\n#include <kernel/mem/mem.h>\n#include <kernel/hal.h>\n#include <string.h>\n\nint handler(void *context) {\n    dprintf(DEBUG, "IRQ handler!\\n");\n    return 0;\n}\n\n\nint driver_scanCallback(pci_device_t *device, void *context) {\n    dprintf(INFO, "Found matching device at bus %d slot %d func %d\\n", device->bus, device->slot, device->function);\n    \n    // Get BAR0\n    pci_bar_t *b = pci_getBAR(device->bus, device->slot, device->function, 0);\n    assert(b);\n\n    // Map it as MMIO\n    uintptr_t m = mem_mapMMIO(b->address, b->size);\n    dprintf(DEBUG, "Mapped memory to 0x%016llX\\n", m);\n    memset(m, 0, b->size);\n\n    mem_unmapMMIO(m, b->size);\n\n    // Enable an MSI interrupt\n    uint8_t irq = pci_enableMSI(device->bus, device->slot, device->function);\n    if (irq == 0xFF) return 1; // MSI not supported or error\n\n    // Register the handler\n    hal_registerInterruptHandler(irq, handler, (void*)0xDEADBEEF);\n\n    return 0;\n}\n\nint driver_init(int argc, char *argv[]) {\n    dprintf(DEBUG, "Scanning for example PCI device with VID 1234 and PID 1111...\\n");\n\n    pci_id_mapping_t id_list[] = {\n        { .vid = 0x1234, .pid = { 0x1111, PCI_NONE }},\n        PCI_ID_MAPPING_END\n    };\n\n    pci_scan_parameters_t params = {\n        .class_code = 0,            // No class code\n        .subclass_code = 0,         // No class code\n        .id_list = id_list\n    };\n\n    return pci_scan(driver_scanCallback, &params, NULL);\n}\n\nint driver_deinit() { return DRIVER_STATUS_SUCCESS; }\n\nstruct driver_metadata driver_metadata = {\n    .name = "Example Driver",\n    .author = "Your Name Here",\n    .init = driver_init,\n    .deinit = driver_deinit\n};\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>s});var t=r(6540);const i={},a=t.createContext(i);function d(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);
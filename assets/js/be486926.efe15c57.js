"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[579],{8437:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>c,toc:()=>o});const c=JSON.parse('{"id":"your-first-driver/scanning-pci","title":"Scanning the PCI bus","description":"Scanning the PCI bus allows you to find your device.","source":"@site/docs/your-first-driver/scanning-pci.md","sourceDirName":"your-first-driver","slug":"/your-first-driver/scanning-pci","permalink":"/docs/your-first-driver/scanning-pci","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Creating the Driver","permalink":"/docs/your-first-driver/creating-the-driver"}}');var s=i(4848),r=i(8453);const t={},a="Scanning the PCI bus",d={},o=[{value:"Start",id:"start",level:2},{value:"Generic PCI device",id:"generic-pci-device",level:2},{value:"Scanning the PCI bus",id:"scanning-the-pci-bus-1",level:2},{value:"Scan parameters",id:"scan-parameters",level:3}];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"scanning-the-pci-bus",children:"Scanning the PCI bus"})}),"\n",(0,s.jsx)(n.p,{children:"Scanning the PCI bus allows you to find your device."}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.p,{children:"If you don't know what PCI is, then feel free to do some extra googling."}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Quick summary"}),": PCI is a system that can let you locate devices like USB controllers, video cards, etc. easily.",(0,s.jsx)(n.br,{}),"\n","Each PCI device has a vendor and device ID. It also has a class code (so you can identify generic devices, extremely helpful)."]}),(0,s.jsx)(n.p,{children:"Each PCI device has configuration space as well, which allows you to toggle features of the device and read information about it."}),(0,s.jsxs)(n.p,{children:["For more information, see the ",(0,s.jsx)(n.a,{href:"https://osdev.wiki/wiki/PCI",children:"OSDev wiki page"})]})]}),"\n",(0,s.jsx)(n.h2,{id:"start",children:"Start"}),"\n",(0,s.jsx)(n.p,{children:"Let's look for our PCI device. Hexahedron provides many kernel APIs for this."}),"\n",(0,s.jsx)(n.p,{children:"First, include the kernel PCI header:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="drivers/example_driver/main.c"',children:"#include <kernel/drivers/pci.h>\n"})}),"\n",(0,s.jsx)(n.p,{children:"We now have access to the entire kernel PCI API. Hexahedron provides a vast API, so let's go through how to use the most common for a driver."}),"\n",(0,s.jsx)(n.h2,{id:"generic-pci-device",children:"Generic PCI device"}),"\n",(0,s.jsxs)(n.p,{children:["First let's go over the PCI device structure - ",(0,s.jsx)(n.code,{children:"pci_device_t"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="hexahedron/include/drivers/pci.h"',children:"typedef struct pci_device {\n    uint8_t             bus;                // Bus\n    uint8_t             slot;               // Slot\n    uint8_t             function;           // Function\n    uint8_t             class_code;         // Class code\n    uint8_t             subclass_code;      // Subclass code\n    uint16_t            vid;                // Vendor ID\n    uint16_t            pid;                // Product ID\n    void                *driver;            // Driver-specific field                       \n\n    uint32_t            msi_offset;         // MSI offset in configuration space (or 0xFF if not found)\n    uint32_t            msix_offset;        // MSI-X offset in configuration space (or 0xFF if not found)\n\n    int                 valid;              // !!!: Valid device hack\n    uint32_t msix_index;                    // MSIX index\n} pci_device_t;\n"})}),"\n",(0,s.jsx)(n.p,{children:"The only fields you want are at the top. These PCI device structures are all arranged in an array so updating one will update it for everyhting else."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"bus"}),", ",(0,s.jsx)(n.code,{children:"slot"}),", and ",(0,s.jsx)(n.code,{children:"function"})," are all specific to the location of the PCI device on the system."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"class_code"})," and ",(0,s.jsx)(n.code,{children:"subclass_code"})," give details on the function of the device"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"vid"})," and ",(0,s.jsx)(n.code,{children:"pid"})," provide the aforementioned vendor and device IDs"]}),"\n",(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsxs)(n.p,{children:["Hexahedron's PCI API tends to flip flop between using ",(0,s.jsx)(n.code,{children:"pci_device_t"})," and accepting ",(0,s.jsx)(n.code,{children:"bus"}),", ",(0,s.jsx)(n.code,{children:"slot"}),", ",(0,s.jsx)(n.code,{children:"func"})," manually."]}),(0,s.jsxs)(n.p,{children:["Gradually, the goal is to switch over to ",(0,s.jsx)(n.code,{children:"pci_device_t"})," fully."]})]}),"\n",(0,s.jsx)(n.h2,{id:"scanning-the-pci-bus-1",children:"Scanning the PCI bus"}),"\n",(0,s.jsxs)(n.p,{children:["The API to scan the PCI bus is ",(0,s.jsx)(n.code,{children:"pci_scanDevice"}),", declared as so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"int pci_scanDevice(pci_scan_callback_t callback, pci_scan_parameters_t *parameters, void *data); \n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"callback"})," contains the scan callback. For each device that matches ",(0,s.jsx)(n.code,{children:"parameters"}),", callback is called."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"parameters"})," will be covered later (note that it is optional, you can leave it as NULL to enumerate ",(0,s.jsx)(n.em,{children:"every PCI device"}),")"]}),"\n",(0,s.jsx)(n.p,{children:"Callback have the following signature:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"/**\n * @brief PCI scan callback function\n * @param device The device currently being checked\n * @param data Driver-specific\n * @returns 1 on an error, 0 on success\n */\ntypedef int (*pci_scan_callback_t)(pci_device_t *device, void *data);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"data"})," is passed directly as it was in ",(0,s.jsx)(n.code,{children:"pci_scanDevice"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Returning 1 means that an error occurred, and to ",(0,s.jsxs)(n.strong,{children:["stop the scan and return an error from ",(0,s.jsx)(n.code,{children:"pci_scanDevice"})]})]}),"\n",(0,s.jsx)(n.h3,{id:"scan-parameters",children:"Scan parameters"}),"\n",(0,s.jsx)(n.p,{children:"Scan parameters are the most complicated part of this interface. Let's look at an example from the UHCI driver."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="drivers/usb/uhci/uhci.c"',children:"pci_scan_parameters_t params = {\n    .class_code = 0x0C,     // Serial bus controller \n    .subclass_code = 0x03,  // Universal Serial Bus\n    .id_list = NULL,        // Optional ID list\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>a});var c=i(6540);const s={},r=c.createContext(s);function t(e){const n=c.useContext(r);return c.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),c.createElement(r.Provider,{value:n},e.children)}}}]);